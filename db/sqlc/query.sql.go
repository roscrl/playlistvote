// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.17.2
// source: query.sql

package sqlc

import (
	"context"
	"database/sql"
)

const addPlaylist = `-- name: AddPlaylist :execresult
INSERT INTO playlists (id, upvotes, added_at)
VALUES (?, ?, ?)
`

type AddPlaylistParams struct {
	ID      string
	Upvotes int64
	AddedAt int64
}

func (q *Queries) AddPlaylist(ctx context.Context, arg AddPlaylistParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, addPlaylist, arg.ID, arg.Upvotes, arg.AddedAt)
}

const getPlaylist = `-- name: GetPlaylist :one
SELECT id, upvotes, added_at
FROM playlists
WHERE id = ?
`

func (q *Queries) GetPlaylist(ctx context.Context, id string) (Playlist, error) {
	row := q.db.QueryRowContext(ctx, getPlaylist, id)
	var i Playlist
	err := row.Scan(&i.ID, &i.Upvotes, &i.AddedAt)
	return i, err
}

const getPlaylistUpvotes = `-- name: GetPlaylistUpvotes :one
SELECT upvotes
FROM playlists
WHERE id = ?
`

func (q *Queries) GetPlaylistUpvotes(ctx context.Context, id string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getPlaylistUpvotes, id)
	var upvotes int64
	err := row.Scan(&upvotes)
	return upvotes, err
}

const getTop100PlaylistsByUpvotesInMonth = `-- name: GetTop100PlaylistsByUpvotesInMonth :many
SELECT id, upvotes, added_at
FROM playlists
WHERE strftime('%Y-%m', added_at / 1000, 'unixepoch') = ?1
ORDER BY upvotes DESC
LIMIT 100
`

// e.g upvotes for March 2023, replace ?1 with '2023-03'.
func (q *Queries) GetTop100PlaylistsByUpvotesInMonth(ctx context.Context, addedAt int64) ([]Playlist, error) {
	rows, err := q.db.QueryContext(ctx, getTop100PlaylistsByUpvotesInMonth, addedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Playlist
	for rows.Next() {
		var i Playlist
		if err := rows.Scan(&i.ID, &i.Upvotes, &i.AddedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTop100PlaylistsByUpvotesPast3Months = `-- name: GetTop100PlaylistsByUpvotesPast3Months :many
SELECT id, upvotes, added_at
FROM playlists
WHERE added_at >= strftime('%s', 'now', '-3 months') * 1000
ORDER BY upvotes DESC
LIMIT 100
`

func (q *Queries) GetTop100PlaylistsByUpvotesPast3Months(ctx context.Context) ([]Playlist, error) {
	rows, err := q.db.QueryContext(ctx, getTop100PlaylistsByUpvotesPast3Months)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Playlist
	for rows.Next() {
		var i Playlist
		if err := rows.Scan(&i.ID, &i.Upvotes, &i.AddedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTop100PlaylistsByUpvotesPastMonth = `-- name: GetTop100PlaylistsByUpvotesPastMonth :many
SELECT id, upvotes, added_at
FROM playlists
WHERE added_at >= strftime('%s', 'now', '-1 months') * 1000
ORDER BY upvotes DESC
LIMIT 100
`

func (q *Queries) GetTop100PlaylistsByUpvotesPastMonth(ctx context.Context) ([]Playlist, error) {
	rows, err := q.db.QueryContext(ctx, getTop100PlaylistsByUpvotesPastMonth)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Playlist
	for rows.Next() {
		var i Playlist
		if err := rows.Scan(&i.ID, &i.Upvotes, &i.AddedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTop100PlaylistsByUpvotesPastWeek = `-- name: GetTop100PlaylistsByUpvotesPastWeek :many
SELECT id, upvotes, added_at
FROM playlists
WHERE added_at >= strftime('%s', 'now', '-7 days') * 1000
ORDER BY upvotes DESC
LIMIT 100
`

func (q *Queries) GetTop100PlaylistsByUpvotesPastWeek(ctx context.Context) ([]Playlist, error) {
	rows, err := q.db.QueryContext(ctx, getTop100PlaylistsByUpvotesPastWeek)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Playlist
	for rows.Next() {
		var i Playlist
		if err := rows.Scan(&i.ID, &i.Upvotes, &i.AddedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTop500PlaylistsByUpvotesAllTime = `-- name: GetTop500PlaylistsByUpvotesAllTime :many
SELECT id, upvotes, added_at
FROM playlists
ORDER BY upvotes DESC
LIMIT 500
`

func (q *Queries) GetTop500PlaylistsByUpvotesAllTime(ctx context.Context) ([]Playlist, error) {
	rows, err := q.db.QueryContext(ctx, getTop500PlaylistsByUpvotesAllTime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Playlist
	for rows.Next() {
		var i Playlist
		if err := rows.Scan(&i.ID, &i.Upvotes, &i.AddedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const incrementPlaylistUpvotes = `-- name: IncrementPlaylistUpvotes :execresult
UPDATE playlists
SET upvotes = upvotes + 1
WHERE id = ?
`

func (q *Queries) IncrementPlaylistUpvotes(ctx context.Context, id string) (sql.Result, error) {
	return q.db.ExecContext(ctx, incrementPlaylistUpvotes, id)
}

const playlistExists = `-- name: PlaylistExists :one
SELECT COUNT(*) FROM playlists WHERE id = ?
`

func (q *Queries) PlaylistExists(ctx context.Context, id string) (int64, error) {
	row := q.db.QueryRowContext(ctx, playlistExists, id)
	var count int64
	err := row.Scan(&count)
	return count, err
}
